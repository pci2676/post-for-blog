## 아이템 3 private 생성자나 열거타입으로 싱글턴임을 보증하라

> p.23 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.  
> 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 mock 구현으로 대체할 수 없기 때문이다.

인터페이스 없이 구현한 싱글턴 코드

```java
public class Validator {
    private static final Validator INSTANCE = new Validator();

    public static final Validator getInstance() {
        return INSTANCE;
    }

    private int bound;

    private Validator() {
        this.bound = 10;
    }

    public void validate(int target) {
        if (target > bound) {
            throw new IllegalArgumentException();
        }
    }

}

class Service {

    private final Validator validator = Validator.getInstance();

    public void validate(int target) {
        validator.validate(target); // validator 가 제대로 작동하는지 테스트를 하려는데 bound 값을 바꿔서 테스트하고 싶다면?
    }
}
```

인터페이스로 정의한 다음 구현한 싱글턴 코드

```java
public interface Validator {
    void validate(int target);
}

class RealValidator implements Validator {
    private static final Validator INSTANCE = new RealValidator();

    private int bound = 10;

    private RealValidator() {
    }

    @Override
    public void validate(int target) {
        if (target > bound) {
            throw new IllegalArgumentException();
        }
    }

}

class MockValidator implements Validator {
    private static final Validator INSTANCE = new MockValidator();

    private int bound;

    private MockValidator() {
    }

    // 테스트를 위한 코드, 이러한 코드는 production 코드에 노출되어선 안되기 때문에 mock 클래스에만 존재한다.
    public void changeMockBound(int mockBound) {
        this.bound = mockBound;
    }

    @Override
    public void validate(int target) {
        if (target > bound) {
            throw new IllegalArgumentException();
        }
    }
}
```

테스트를 유연하게 할 수 있는 구조가 된다.

주의해야할 점

싱글턴 클래스를 직렬화하려면 단순히 `Serializable`을 구현할 것이 아니라, 모든 인스턴스 필드를 `transient`라고 선언해줘야지 역직렬화 할때 새로운 인스턴스가 생성이 안된다.  
혹은 `readResolve()` 메서드를 추가하여 싱글턴임을 보장하자.

```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    // 역직렬화시 새로운 인스턴스 생성 요인 차단방법 1
    // transient 예약어를 추가하여 직렬화를 차단하여 역직렬화시 새로운 인스턴스가 생성되지 못하도록 한다.
    // transient private static final Singleton INSTANCE = new Singleton();

    public static Singleton getInstance() {
        return INSTANCE;
    }

    private Person person;

    private Singleton() {
        person = new Person();
    }

    // 역직렬화시 새로운 인스턴스 생성 요인 차단방법 2
    // 역직렬화시 readResolve 를 재정의하여 기존 인스턴스를 반환하여 싱글턴을 보장하도록 한다.
    private Object readResolve() {
        return INSTANCE;
    }
}

class Person {
}
```

대부분의 상황에서 가장 바람직한 방법은 논리적으로 원소가 하나 뿐인 Enum과 같은 열거형을 이용하여 싱글턴을 구현하는 것이다.

